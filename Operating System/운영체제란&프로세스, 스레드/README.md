### 2023.03 5주차

## 운영체제 (OS, Operating System)

### 운영체제

- HW 또는 SW 리소스들을 효율적으로 사용하기 위한 환경을 제공
- 실행할 프로그램에 필요한 자원들 할당하고, 프로그램을 올바르게 실행되도록 돕는 프로그램
- 하드웨어의 설계를 바탕으로 하드웨어를 동작시키는 소프트웨어

- Mode

  ![프로그램 단계](img/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-28_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.36.25.png "프로그램 단계")

  

  - Kernel Mode : 하드웨어 자원에 대한 완전한 접근 가능
  - User Mode : 하드웨어 자원에 대한 제한적인 접근 가능

    → (하드웨어를 보호하기 위해) 오직 운영체제가 제공하는 명령만 실행

  - 운영체제는 Kernel mode에서 실행되는 소프트웨어

- 운영체제의 기능

  → 제한된 컴퓨터 시스템의 각종 자원을 효율적으로 관리하고 운영하여, 사용자에게 최대한의 편리성을 제공

  ⇒ Application이 하드웨어에게 일을 시킬 수 있도록 도움

  - 사용자 관점 : OS는 사용자에게 추상적인 모습을 제공
    → 사용자가 기계 내부의 일에 대해 알지 못해도 기계를 사용하는데 문제 없음
  - 시스템 관점 : OS는 하드웨어 자원을 효율적으로 관리 (자원의 다중화)



<details>
<summary>자원 다중화</summary>
<div markdown="1"> 

      1. 시간 다중화 
  
         서로 다른 프로그램이나 사용자가 교대로 그 자원을 이용하는 것

         → 사용자가 번갈아 자원을 사용 ⇒ 실제로 병렬적이지 않지만 의사병렬성을 지님
     
      2. 공간 다중화    
  
         각각 자원의 일부를 가지는 것
</div>
</details>


![스크린샷 2023-03-28 오후 9.56.05.png](img/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-28_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.56.05.png)


- API (Application Programming Interface)
  : Application이 OS와 소통하기 위해서는 OS가 제공한 API를 통해 소통
- System Call : 응용 프로그램이 시스템 자원을 사용할 수 있도록, 운영체제 차원에서 다양한 함수 제공

  - System Call을 통한 작업
    - 프로세서 관리 : 프로세스에 CPU를 분배하고 작업에 필요한 제반 환경 제공 ⇒ CPU 스케줄링
    - 메모리 관리 : 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상 공간 제공
    - 파일 시스템 관리 : 데이터 저장하고 접근할 수 있는 인터페이스 제공
    - 입출력 관리 : 필요한 입출력 서비스 제공
    - 프로세스 간 통신 관리 : 공동 작업을 위한 각 프로세스 간 통신 환경 제공

- 일을 시키는 순서
1. 컴퓨터를 조작할 수 있는 권한을 OS로부터 부여 받기
  2. 권한을 부여 받고, OS가 제공하는 기능 이용 가능
  - 예) Word에서 프린터를 통해 인쇄하기
    1. Word는 OS로부터 프린터 사용 권한 부여 받기
    2. 프린터를 사용할 때 필요한 API 호출

## 프로세스와 스레드 (Process & Thread)

- 프로그램 : 파일 단위로 저장 장치에 저장되어 있으며 아직 실행되지 않은 코드 덩어리

## 프로세스 (Process)

- OS로부터 자원을 할당받은 작업의 단위 ⇒ 메모리 공간을 할당 받아 실행 중인 프로그램
- OS는 프로세스 마다 각각 독립된 메모리 영역을 Code / Data / Stack / Heap 형식으로 할당

  - Code : 프로세스가 실행할 코드가 기계어의 형태로 저장 (Compile 시 결정)
  - Data : 전역 변수, static 변수 저장 (Compile 시 결정)
  - Stack :
    - 함수의 매개변수, return 주소, 로컬 변수와 같은 임시 값 저장 (Compile 시 결정)
    - 스택의 LIFO 방식에 따라 함수 호출 시 기록하고 종료 시 제거
    - 정해진 크기가 있어 stack overflow 에러 발생 가능
  - Heap : 프로세스 실행 중 동적으로 할당되는 값 (Runtime 시 결정, 프로그래머가 관리하는 영역)

- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다 ⇒ IPC (Inter Process Communication)을 사용하여 접근

![스크린샷 2023-03-31 오후 10.21.28.png](img/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-31_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.21.28.png)

- 프로세스 제어 블록 (PCB, Process Control Block)

  - 프로세스 제어 블록 : 특정 프로세스에 대한 정보를 담고 있는 OS의 자료구조
  - OS의 스케줄링에 따라 프로세스 전환이 발생하면 실행한 정보를 저장 또는 재실행 시 이전 작업의 진행 정보를 저장하는 공간
  - 프로세스 생성과 동시에 고유한 PCB도 생성

  - PCB에 저장되는 정보
    - 프로세스 식별자 (PID, Process ID)
    - 프로그램 카운터 (Program counter) : 프로세스가 다음에 실행할 명령어의 주소를 가리킴
    - CPU 레지스터 : Accumulator, Index Register, 범용 레지스터 등
    - CPU 스케줄링 정보 : 프로세스 우선순위, 최종 실행 시각, CPU 점유 시간 등
    - 메모리 관리 정보 : Page table, Segment table 등
    - 계정 정보 : CPU 사용 시간, 제한 시간, 계정 정보 등
    - 입출력 상태 정보 : 프로세스에 할당된 입출력 장치, 개방된 파일 목록 등
    <details>
      <summary>프로세스 상태 (Process state)</summary>
      <div markdown="1">

       - Running : CPU를 잡고 instruction을 수행 중
       - Ready : CPU를 기다리는 상태 (메모리 등 다른 조건은 만족, CPU만 얻으면 실행 가능)
       - Block (or wait, sleep) :   
              CPU를 주어도 당장 instruction을 수행할 수 없는 상태   
              프로세스 자신이 요청한 event가 즉시 만족되지 않아 기다리는 상태
       - New : 프로세스 생성 중
       - Terminated : 프로세스가 종료 중인 상태 (수행이 끝난 상태)
        
      ![프로세스 상태도](img/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-31_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.50.48.png)

      </div>
    </details>
       

## 스레드 (Thread)

- 프로세스가 할당 받은 자원을 이용하는 실행 흐름의 단위
- 프로세스의 작업들을 실행 흐름에 따라 분리한 것
- 프로세스 안에 존재하며 기본적으로 프로세스는 최소 1개의 스레드(메인 스레드)를 보유
- 프로세스 내에서 Stack만 할당받고 Code, Data, Heap 영역은 공유
  - 독립적 : 레지스터, 스택, 고유한 스레드 ID, 프로그램 카운터 (PC)
  - 공유 : 프로세스 내의 코드, 데이터, 힙 영역, 기타 OS 자원   
    ⇒ 프로세스 메모리 영역을 공유하기 때문에 어떤 스레드 하나에서 오류가 발생하면 같은 프로세스 내의 다른 스레드 모두 강제 종료 (강제 종료되도 공유 자원을 손상시키지 않는다면 다른 스레드에 영향 X)

![스크린샷 2023-04-03 오후 8.34.49.png](img/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-03_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.34.49.png)

### 동시성 - Concurrent vs Parallel

- Concurrent : 어떤 작업 여러 개가 동시에 처리 (멀티)
- Parallel : 어떤 하나의 작업을 쪼개서 여러 sub 작업으로 나누고, 이를 물리적으로 분리된 구조에서 동시에 처리해서 완성

⇒ parallelism 없이 concurrency를 가지는 것이 가능

![스크린샷 2023-04-03 오후 9.26.46.png](img/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-03_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.26.46.png)

### Context Switching (문맥교환) ⭐

- CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정
- CPU가 다른 프로세스에게 넘거갈때 OS는 다음을 수행
  - CPU를 내어주는 프로세스의 상태를 그 프로세스 PCB에 저장
  - CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴
- System call이나 Interrupt가 발생 시 항상 Context Switching이 발생하는 것은 아님
  (프로세스 A → 커널모드 → 프로레스 A인 경우)
  ![스크린샷 2023-04-03 오후 9.11.32.png](img/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-03_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.11.32.png)

## 멀티 프로세스 vs 멀티 스레딩

### 멀티 프로세스

하나의 응용 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(task) 처리

- 장점
  - 프로세스 중 하나에 문제가 발생했을 경우 다른 프로세스는 영향 X
- 단점
  - Context Switching이 발생하면 CPU 레지스토와 캐쉬에 있는 데이터를 모두 리셋 → 매우 큰 오버헤드
  - 프로세스는 각각의 독립된 메모리 영역을 할당 받았기 때문에 프로세스 사이의 통신을 위해 IPC를 이용

### 멀티 스레드

하나의 프로세스를 여러 개의 스레드로 구성하여 각 스레드가 하나의 작업 처리

![스크린샷 2023-04-03 오후 9.30.24.png](img/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-03_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.30.24.png)

- 장점
  - 스레드 간 데이터 공유가 가능 → 데이터 주고 받기 비교적 수월
  - Context Switching 발생 시 stack 영역만 처리 → 적은 오버헤드
  - 더 적은 메모리 영역 필요 → 시스템의 자원 소모도 감소
- 단점
  - 스레드 중 하나에 문제가 발생했을 때 전체 프로세스에 영향
  - 자원을 공유하기 때문에 동기화 문제

### 정리

멀티 스레드는 멀티 프로세스에 비해

1. 자원의 효율성 증대
   - 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리
2. 처리 비용 감소, 응답 시간 단축

   - IPC 보다 스레드 간이 통신 비용이 적어 작업들 간의 낮은 통신 부담
     → Stack을 제외한 모든 메모리를 공유하기 때문
   - 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠름

   의 이점이 있지만

3. 스레드에 문제가 생겼을 때 전체 프로세스에 영향이 생긴다는 것과
4. 동기화 문제가 발생

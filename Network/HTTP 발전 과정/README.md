# HTTP (Hyper Text Transfer Protocol)

## HTTP/0.9 
표준 이전의 HTTP 버전으로 문서화된 최초의 HTTP 버전   
단순한 Client-Server 구조였던 초기 웹은 단순히 HTML을 요청하고 전송하는 것이 전부였다.
그리고 HTTP는 TCP/IP 프로토콜 위에서 작동했기때문에 최적화 설정들을 신경쓰지 않았다.

요청 메소드는 `GET` 단 하나에 `헤더`, `상태코드`도 존재하지 않았다.
- 요청
    ```
    GET /page.html
    ```
- 응답
    ```
    <HTML>
        My Page...
    </HTML>
    ```
이후 웹 사용자의 증가에 따라 요구사항을 충족시키기 위해 브라우저들은 각자 여러 기능들을 추가하였다.   
하지만 약속된 표준이 없어 원활하게 통신이 이루어지지 않았고,   
이러한 사양들을 정의하여 발표한 것이 `HTTP/1.0`이다.
> HTTP0.9인 이유? -> HTTP 1.0과 구분을 위해 최초의 버전에 0.9라는 이름을 붙임

## HTTP/1.0
HTTP/1.0에서 변경된 사항
- 버전 정보의 명시   
    - Request와 Response 사이에 버전 정보가 명시되었다.
- 요청 메소드의 확장 
    - `GET`, `HEAD`, `POST` 세 가지로 확장되었다.
- 상태 코드의 추가
- 메타데이터를 담는 `헤더`의 추가
    - 헤더의 `Content-Type`으로 `HTML` 이외의 파일을 전송할 수 있게 되었다.
- 요청
    ```
    GET /page.html HTTP/1.0
    User-Agent: NCSA_Mosaic/2.0(Windows 3.1)
    ```
- 응답
    ```
    200 OK
    Date: Tue, 15 Nov 1994 08:12:31 GMT
    Server: CERN/3.0 libwww/2.17
    Content-Type: text/html
    <HTML>
        My Page...
        <Img src="/img.jpeg">
    </HTML>
    ```

## HTTP/1.1
HTTP/1.0의 설계에서의 다음과 같은 불완전한 부분들을 보완하고자 추가되었다.
- 계층적 프록시
- 캐싱
- 연결 지속성

### 연결 상태 유지(Persisted connection)
HTTP/1.0에서는 Response가 수신되면 곧바로 TCP 연결을 종료한다.     
웹 페이지가 복잡해지면서 다수의 요청이 발생할 때마다 TCP 연결(3Way-Handshake) 과정을 거쳐야 해서 속도가 매우 느려졌다.   

그래서 HTTP/1.1에서는 사용했던 TCP 연결을 재사용하도록 했다. 연결하고 종료하는 과정에서 시간이 줄어들긴 하지만 연결이 계속된다면 서버에 부하가 생기게 되므로 시간을 정해놨으며 이를 `Keep-Alive`라고 칭한다.

<div align="center">
    <img height=500px width=500px src="https://user-images.githubusercontent.com/70866410/235617941-6faa1f07-e400-49e5-a58d-a7b46b0d38a4.png">
</div>

### 파이프 라인(Pipe-lining)
파이프라이닝이란, 클라이언트가 서버에게 여러 요청을 보낼 때 요청에 대한 응답을 기다리는 것이 아니라 발생한 요청을 모두 전송하는 방식이다.   
기존 방식은 여러 요청이 발생하면 먼저 `(1)`발생한 요청을 보내고 `(2)`그에 대한 응답을 받고 `(3)`다음 요청을 보낸다.   
이 경우 앞선 요청의 시간에 따라 이후 요청의 지연이 발생할 수 있었다.

그래서 HTTP/1.1에서는 파이프라이닝을 이용해 여러 요청을 보내면 서버는 받은 순서대로 응답하며 지연을 줄이도록 했다.   
❗❗이 때 가장 중요한 것은 요청별 응답을 위해 순서를 엄격히 지켜야 한다.

이 외에도 HTML을 분할하는 `청크 전송 인코딩(Chunked Transfer Encoding)`이나, 요청에 대한 메타 정보를 담는 `캐시 제어`, 동일 IP에 여러 도메인을 호스팅할 수 있는 `호스트`등의 기능이 추가되었다.

## HTTP/2.0
시간이 지나면서 웹 서비스들은 더욱 복잡해졌고, HTTP/1.1로 해결할 수 없는 한계들이 드러났다.

### HOLB - HEAD of Line Blocking
HTTP/1.1에서는 `Multiflexing`을 할 수 없어 요청을 순차대로 처리할 수 밖에 없었다.   

예를 들어, 세 개의 요청이 있다고 했을 때 첫 번째 요청을 처리하는데 `20초`가 걸린다고 
하자. 두 번째와 세 번째 요청은 각각 `1초`가 걸린다고 하면 뒤의 두 요청은 `20초, 21초`를 기다려야만 처리될 수 있는 것이다.   
이런 상황을 `HOLB`라고 한다.

HTTP/1.1에서는 물리적인 TCP 연결을 병렬로 하여 임시적으로 해결하였다.   
TCP 연결의 수는 브라우저마다 다르지만 일반적으로 `최대 6개`를 지원한다고 한다.

<div align="center">
    <img src="https://user-images.githubusercontent.com/70866410/235826322-1aeea29a-b15c-4497-a4b0-fafb9ffd5001.png">
</div>
HTTP/2.0에서는 이런 문제를 해결하기 위해 텍스트 기반 프로토콜이 아닌 이진 프로토콜 위에서 동작한다.   

SPDY프로토콜에서는 데이터를 `이진화(Binary Framing)`하는 계층이 있어 텍스트 기반 전송보다 훨씬 효율적으로 데이터를 송수신할 수 있다.

또한 Multiflexing이 가능해져 하나의 TCP 연결에서 여러 요청을 동시에 처리할 수 있게 되었다.  

<b>Mulitflexing</b>   
HTTP/2.0에서는 하나의 TCP연결을 다음과 같이 세분화한다.
- 스트림 : 요청과 응답이 `양방향`으로 오가는 `논리적` 단위이며 여러개의 스트림이 동시에 존재할 수 있다.
- 메시지 : 하나의 요청과 하나의 응답을 구성하는 단위
- 프레임 : 메시지를 구성하는 최소 단위로 잘게 쪼개어서 전송하며 수신측은 이를 재조립하여 사용한다.

<div align="center">
    <img src="https://user-images.githubusercontent.com/70866410/235833091-5aac3e4b-04c9-454d-b20a-cbb0978d8d6f.png">
</div>

위의 사진에선 Stream1, Stream3, Stream5가 동시에 존재한다.      
또한, Stream1 사이에 Stream3이 섞여서 전송되고 있으며, 수신측은 이를 재조립 하여 사용한다.
HTTP/2.0에서는 이러한 방식을 통해 `HOLB` 문제를 해소한다.

### 헤더의 중복
HTTP/1.1는 헤더에 많은 메타데이터가 담긴다. 이를 매 요청마다 중복해서 전달해야만 했고 심지어는 전송 데이터보다 헤더가 큰 경우도 존재했다.   
이는 결국 통신시간의 지연을 유발하게 된다.

<div align="center">
    <img src="https://user-images.githubusercontent.com/70866410/235833691-c80d5e9a-5cde-4ff2-bb59-ddbb475336ab.png">
</div>

HTTP/2.0에서는 `헤더필드 압축`을 통해 이를 해소하였는데, `HPACK`이라고 부르며 달라진 부분만을 다시 전송하는 허프만 코딩을 사용한다. 변경이 없는 부분은 보내지 않기때문에 발생하는 오버헤드를 최소화할 수 있다.

이외에도 HTTP/2.0에는 클라이언트의 요청 없이도 서버가 먼저 리소스를 보낼 수 있는 `서버 푸시`, 트리 구조로 구현된 `스트림별 우선순위 지정`등이 포함되어 있다.

## HTTP/3
HTTP/2.0까지도 TCP 프로토콜에서 동작하기 때문에 `HOLB`문제를 완전히 해소할 수 없었다. TCP 특성상 중간에 데이터가 손실되었을 때 재전송을 수행한다. 그리고 데이터를 순서대로 처리해야 하므로 재전송하는 과정에서 지연이 발생했다.

또한 TCP는 송-수신측의 데이터 처리 속도 차이를 제어하는 `혼잡제어`를 수행하는데, 느린 전송속도부터 천천히 높여가는 방식으로 동작한다.    
이는 네트워크 상황이 원활할 때도 불필요한 지연이 발생한다.

이런 근본적인 문제의 해결을 위해 HTTP/3은 구글이 자체 개발한 `UDP` 기반의 `QUIC` 프로토콜에서 동작한다.   
UDP 기반 프로토콜은 기본적인 신뢰성을 보장하지 않는다. 이런 신뢰성, 혼잡 제어 기능들을 직접 구현해 추가한 것이 `QUIC`인 것이다.

### HandShake
HTTP/3에서는 이전의 연결 정보를 캐싱하여 재사용하는 0-RTT, 1-RTT를 제공한다. 핸드셰이크 과정을 크게 줄여 지연시간을 줄일 수 있었다.   
핸드셰이크 과정이 별 것 아닌 것 같지만, 서버와 클라이언트가 서로 지구 반대편에 있고 빛이 지구 반대편에 도달하고 다시 돌아오는데 걸리는 시간은 약 130ms다. 왕복이므로 매 연결마다 약 270ms가 소모되는데 이를 줄일 수 있는 것이다.

링크 : [1-RTT, 0-RTT](https://luavis.me/server/tls-1.3)
<div align="center">
    <img src="https://user-images.githubusercontent.com/70866410/236083401-684c9973-c5fe-4742-8678-8b3beac2759d.png">
</div>

### 다중화 Multiflexing
HTTP/3은 연결 다중화를 완전하게 지원하며, 각각의 스트림이 `독립적`으로 동작한다.

<div align="center">
    <img src="https://user-images.githubusercontent.com/70866410/236089968-acb9acb8-383f-417e-b9e0-bdd720fceaa4.png">
</div>

HTTP/2.0에서 여러 스트림을 동시에 사용할 수 있으나 TCP 프로토콜이므로 데이터 손실이 발생했을 때 재전송하며 지연이 발생한다.    
HTTP/3에서는 스트림이 완전하게 독립적이므로 데이터 손실이 발생해도 다른 스트림에 영향을 주지 않는다.

또한 HTTP/3은 IP 기반이 아닌 연결마다 고유한 UUID를 사용하여 연결을 식별한다. 덕분에 WI-FI에서 셀룰러 환경으로 이동해도, 그 반대의 경우에도 재 연결 과정이 필요없어진다.

HTTP/3 역시 `HPACK`과 유사하게 `QPACK`을 이용해 헤더압축이 이루어진다. 스트림이 독립적으로 동작하므로 그에 맞춰 개선된 방안이다.

### 참고자료
---
[요즘IT : 웹 개발자라면 알고 있어야 할 HTTP의 진화 과정](https://yozm.wishket.com/magazine/detail/1686/)
# TDD

> 기능 개발에 앞서 기능을 가정하고, 그 가정에 대한 테스트 작성하며 테스트가 통과하도록 만들고, 이를 개선하는 짧은 과정을 반복

- 프로그래밍 의사결정과 피드백 사이에 간극을 의식하고 제어하는 기술
- 테스트 기술이 아닌 **분석 기술** 및 **설계기술**

# TDD 사이클

![NSChart.png](markdownResource%2Ftddcycle.png)

1. **질문** : 실패하는 테스트를 구현하자.
2. **응답** : 테스트가 성공하도록 프로덕션 코드를 구현하자.
3. **정제** : 프로덕션 코드와 테스트 코드를 리팩토링하자.

## 테스트란?

승인 혹은 거부에 도달하는 과정을 의미한다. 크게 2가지로 분류할 수 있다.

1. 명사적 의미의 테스트 : 자동으로 실행되는 테스트 과정
   - 개발자가 xUnit와 같은 API, 프레임워크를 이용해 자동화된 테스트 수행
2. 동사적 의미의 테스트 : 버튼을 눌러보거나 화면의 출력 결과를 테스트
   - QA가 수행하는 기능 테스트 등

---

# 본격적인 예제에 앞서

> Java 언어를 주로 활용하고 있기에 Junit에 대해 알아본 뒤 수행해보자

## Junit 개념

- Java에서 프로그램 단위 테스트를 위한 대표적인 프레임워크

## Junit 특징

- `@Test`의 메소드가 호출될 때 마다 새로운 인스턴스를 생성해 독립적인 테스트를 수행한다.
- assertXXXXX 메소드로 TC(테스트 케이스)의 수행 결과를 판단한다.
- 어노테이션을 제공함 -> 쉽고 간결하게 테스트 코드 작성할 수 있다.

## Assertion?

> Spring을 사용해 TDD 구현시 `Assert`가 포함된 메소드, 클래스를 자주 만날 것이다.
> 그럼 Assert가 뭘까?

`Assert` : 테스트 검증 과정을 위한 개념

- 특정 코드 부분이 예상한대로 동작하는지 **확인**하기 위한 동작.
- 개발자가 특정 지점에 대해 반드시 참이라고 생각하는 사항을 표현한 논리 방식이다.
  - 실행 결과가 참 -> 테스트 성공
  - 실행 결과가 실패 -> 테스트 실패

### Assertion의 메소드

| 제목                                         | 내용                                                                                          |
| -------------------------------------------- | --------------------------------------------------------------------------------------------- |
| `Assert.fail(message)`                       | 메소드 실행 결과를 실패로 만든다. <br> 테스트 구현에 앞서 placeholder로 활용 가능하다. <br>   |
| `Assert.assertEquals("출력글", a, b)`        | a와 b가 같은지 테스트한다. <br> 같으면 성공 & 같지 않으면 실패, 실패하면 "출력글"을 출력한다. |
| `Assert.assertEquals("출력글", a, b, delta)` | a와 b가 delta 범위 내에서 같은지 테스트한다.                                                  |
| `Assert.assertArrayEquals(array1, array2)`   | array1과 array2가 일치하는지 테스트한다.                                                      |

### 테스트 어노테이션

| 제목                                     | 내용                                                                          |
| ---------------------------------------- | ----------------------------------------------------------------------------- |
| `@Test`                                  | 해당 메소드가 테스트 대상임을 의미                                            |
| `@Test(timeout=10)`                      | 테스트 메소드 수행시간이 10ms를 넘기면 실패                                   |
| `@Test(expected=RuntimeException.class)` | RuntimeException 발생하면 성공!                                               |
| `@Before`                                | 각 테스트 메소드에서 공통적으로 실행해야할 작업 포함. <br> 테스트 실행전 쉴행 |
| `@After`                                 | 각 테스트 메소드에서 실행이 완료된 후 동일한 마무리 작업 수행할 때            |
| `@BeforeClass`                           | static이며, 모든 메소드 수행전 공통작업                                       |
| `AfterClass`                             | static이며, 모든 메소드 수행 후 1딱 1번 수행                                  |

# 실전예제

## 예제 1 - 일반Java

> 피보나치 수열을 TDD로 구현해보자

## 예제 2 - Spring 프레임워크 활용

> 멤버십 적립 서비스

- 제휴업체는 네이버, 카카오, 라인 3가지가 있으며 **고객이 원하는** 멤버십 등록가능
- 포인트 적립 비율은 1%, 추후 고정금액(1000원)으로 확장해 적립할 수 있다.
- REST API를 정의하고, TDD 방식으로 구현

### 예제 2 - 기능 요구사항

- 멤버십 연결하기, 나의 멤버십 조회, 멤버십 연결끊기, 포인트 적립 API 를 구현합니다.
- 사용자 식별값은 문자열 형태이며 "X-USER-ID" 라는 HTTP Header 로 전달되며, 이 값은 포인트 적립할 때 바코드 대신 사용됩니다.
- Content-type 응답 형태는 application/json(JSON) 형식을 사용합니다.
- 각 기능 및 제약사항에 대한 개발을 TDD, 단위테스트를 기반으로 진행해야 합니다.

### 예제 2 - 상세 기술 구현 사항

- 나의 멤버십 등록 API
  - 기능: 나의 멤버십을 등록합니다.
  - 요청: 사용자 식별값, 멤버십 이름, 포인트
  - 응답: 멤버십 ID, 멤버십 이름
    <br>
- 나의 멤버십 전체 조회 API
  - 기능: 내가 가진 모든 멤버십을 조회합니다.
  - 요청: 사용자 식별값
  - 응답: {멤버십 ID, 멤버십 이름, 포인트, 가입 일시}의 멤버십 리스트
    <br>
- 나의 멤버십 상세 조회 API
  - 기능: 나의 1개 멤버십을 상세 조회합니다.
  - 요청: 사용자 식별값, 멤버십 ID
  - 응답: 멤버십 ID, 멤버십 이름, 포인트, 가입일시
    <br>
- 나의 멤버십 삭제 API
  - 기능: 나의 멤버십을 삭제합니다.
  - 요청: 사용자 식별값, 멤버십 번호
  - 응답: X
    <br>
- 멤버십 포인트 적립 API
  - 기능: 나의 멤버십 포인트를 결제 금액의 1%만큼 적립합니다.
  - 요청: 사용자 식별값, 멤버십 ID, 사용 금액을 입력값으로 받습니다.
  - 응답: X

# 참고

## Spring에서 TDD 방법

- Repository -> Service -> Controller 순서로 개발을 진행한다.
  - Repository는 다른 계층에 대한 의존성이 없기 때문에 TDD flow가 매끄러워진다.
- Repository 계층의 테스트는 H2와 같은 인메모리 데이터베이스 기반의 통합 테스트로 진행한다.
- Service 계층의 테스트는 Mockito를 사용해 Repository 계층을 Mock하여 진행한다.
- Controller 계층의 테스트는 SpringTest의 MockMvc를 사용해 진행한다

<br>  
## Assertion VS Exception
### Assertion
- 목적 : 코드의 가정과 조건을 명시적으로 표현 -> 디버깅 및 코드 검증
- 사용방식 : 개발자가 코드에서 가정한 조건이 참인지 **확인**하기 위함 -> 참이 아닐 경우 `Assertion 에러 발생`
- 프로덕션 코드에서 **비활성화**

<br>

### Exception

- 목적 : 프로그램 실행 중 예기치 않은 상황이 발생했을 때 처리, 오류조건 전파
- 사용방식 : 실행 중에 예기치 않은 상황이 발생했을 때 해당 흐름을 나타내는 예외 객체 생성을 위한 전파
- 프로덕션 코드에서 **비활성화**
